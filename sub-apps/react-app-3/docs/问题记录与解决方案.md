# React-App-3 问题记录与解决方案

## 概述

本文档记录了在开发 `sub-apps/react-app-3`（订单管理系统）过程中遇到的所有问题、详细分析、解决方案和预防措施。该子应用基于 React + Context API 构建，支持 qiankun 微前端框架。

## 目录

1. [Qiankun生命周期函数导出问题](#1-qiankun生命周期函数导出问题)
2. [ES模块导入错误问题](#2-es模块导入错误问题)
3. [与react-app-2对齐的重构过程](#3-与react-app-2对齐的重构过程)
4. [主应用setup.ts语法错误修复](#4-主应用setupts语法错误修复)
5. [路由配置问题](#5-路由配置问题)
6. [TypeScript类型错误](#6-typescript类型错误)
7. [预防措施和最佳实践](#7-预防措施和最佳实践)

---

## 1. Qiankun生命周期函数导出问题

### 问题描述

在集成qiankun微前端框架时，遇到生命周期函数导出和识别问题：

```javascript
// 错误信息
Uncaught TypeError: Cannot read properties of undefined (reading 'bootstrap')
qiankun: application 'react-order-management' died in status LOADING_SOURCE_CODE
```

### 根本原因分析

1. **生命周期函数导出方式不正确**
   - 使用了错误的导出语法
   - 生命周期函数未正确挂载到全局对象

2. **qiankun插件配置问题**
   - `vite-plugin-legacy-qiankun` 插件使用不当
   - 生命周期创建函数调用时机错误

3. **全局变量检测问题**
   - `__POWERED_BY_QIANKUN__` 检测逻辑有误
   - 环境判断条件不准确

### 具体错误代码

**错误的实现方式：**
```typescript
// ❌ 错误：直接导出可能导致undefined
export async function bootstrap() {
  console.log('bootstrap');
}

export async function mount(props: any) {
  render(props);
}

export async function unmount() {
  if (reactRoot) {
    reactRoot.unmount();
  }
}
```

### 解决方案

**正确的实现方式：**
```typescript
// ✅ 正确：使用插件辅助函数
import { createLifecyle, getMicroApp } from 'vite-plugin-legacy-qiankun';
import { globalLogger } from './shared-stub';

// 获取微应用实例
const microApp = getMicroApp('react-order-management');

// 判断是否在qiankun环境下运行
if (microApp.__POWERED_BY_QIANKUN__) {
  // 使用createLifecyle导出生命周期函数
  createLifecyle('react-order-management', {
    bootstrap() {
      globalLogger.info('React Order Management app bootstrapped');
    },
    mount(props: any) {
      globalLogger.info('React Order Management app mounting', props);
      
      // 验证挂载参数
      if (!props || !props.container) {
        const error = new Error('Invalid mount props: container is required');
        globalLogger.error('Mount failed', error, { props });
        throw error;
      }
      
      render(props);
    },
    unmount() {
      globalLogger.info('React Order Management app unmounting');
      
      // 使用保存的 root 实例进行卸载
      if (reactRoot) {
        reactRoot.unmount();
        reactRoot = null;
      }
    },
  });
} else {
  // 独立运行模式
  render();
}
```

### 关键改进点

1. **使用插件辅助函数**
   - 利用 `createLifecyle` 确保正确的导出格式
   - 通过 `getMicroApp` 获取应用实例

2. **增强错误处理**
   - 添加挂载参数验证
   - 完善日志记录

3. **改善资源管理**
   - 正确管理 React root 实例
   - 确保卸载时资源清理

---

## 2. ES模块导入错误问题

### 问题描述

在开发过程中遇到ES模块导入相关的错误：

```javascript
// 错误信息
SyntaxError: The requested module '/src/shared-stub.ts' does not provide an export named 'globalEventBus'
Module not found: Can't resolve '@shared/communication'
```

### 根本原因分析

1. **导入路径错误**
   - 使用了不存在的共享模块路径
   - 模块别名配置不正确

2. **导出声明不匹配**
   - 导入的名称与实际导出不符
   - 默认导出和命名导出混用

3. **模块依赖缺失**
   - 共享库未正确安装或配置
   - 路径解析配置问题

### 具体错误代码

**错误的导入方式：**
```typescript
// ❌ 错误：导入不存在的模块
import { createMicroAppNavigation } from '@shared/communication/navigation/micro-app-integration';
import { globalEventBus, globalStateManager } from '@shared/communication';

// ❌ 错误：导入不存在的导出
import { nonExistentExport } from './shared-stub';
```

### 解决方案

**创建本地存根文件：**
```typescript
// src/shared-stub.ts
/**
 * 共享库存根实现
 * 提供基本的事件总线和状态管理功能
 */

// 事件类型定义
export const EVENT_TYPES = {
  APP_READY: 'APP_READY',
  THEME_CHANGE: 'THEME_CHANGE',
  USER_LOGOUT: 'USER_LOGOUT',
  LANGUAGE_CHANGE: 'LANGUAGE_CHANGE',
  ROUTE_CHANGE: 'ROUTE_CHANGE'
} as const;

// 简单的事件总线实现
class SimpleEventBus {
  private listeners: Record<string, Function[]> = {};

  on(eventType: string, callback: Function): void {
    if (!this.listeners[eventType]) {
      this.listeners[eventType] = [];
    }
    this.listeners[eventType].push(callback);
  }

  off(eventType: string, callback: Function): void {
    if (this.listeners[eventType]) {
      this.listeners[eventType] = this.listeners[eventType].filter(
        listener => listener !== callback
      );
    }
  }

  emit(event: any): void {
    const eventType = event.type;
    if (this.listeners[eventType]) {
      this.listeners[eventType].forEach(callback => {
        try {
          callback(event);
        } catch (error) {
          console.error('Event listener error:', error);
        }
      });
    }
  }
}

// 简单的日志记录器
class SimpleLogger {
  info(message: string, data?: any): void {
    console.log(`[INFO] ${message}`, data || '');
  }

  error(message: string, error?: Error, data?: any): void {
    console.error(`[ERROR] ${message}`, error, data || '');
  }

  warn(message: string, data?: any): void {
    console.warn(`[WARN] ${message}`, data || '');
  }
}

// 导出实例
export const globalEventBus = new SimpleEventBus();
export const globalLogger = new SimpleLogger();

// 类型导出
export type EventType = keyof typeof EVENT_TYPES;
export type EventData = {
  type: EventType;
  source: string;
  timestamp: string;
  id: string;
  data?: any;
};
```

**正确的导入方式：**
```typescript
// ✅ 正确：导入本地存根
import { globalEventBus, globalLogger, EVENT_TYPES } from './shared-stub';

// ✅ 正确：条件性导入（如果模块可能不存在）
let navigationAPI: any = null;
try {
  const { createMicroAppNavigation } = await import('@shared/communication/navigation/micro-app-integration');
  navigationAPI = createMicroAppNavigation({
    appName: 'react-app-3',
    // ... 其他配置
  });
} catch (error) {
  console.warn('Navigation module not available, using fallback');
}
```

### 关键改进点

1. **创建本地存根**
   - 提供基本功能实现
   - 确保应用可以独立运行

2. **渐进式集成**
   - 支持可选的共享模块
   - 优雅降级处理

3. **类型安全**
   - 完整的TypeScript类型定义
   - 编译时错误检查

---

## 3. 与react-app-2对齐的重构过程

### 问题描述

为了保持项目一致性，需要将 react-app-3 的结构和配置与 react-app-2 对齐，但在重构过程中遇到了多个兼容性问题。

### 对齐目标

1. **目录结构对齐**
2. **配置文件格式统一**
3. **依赖版本一致**
4. **代码风格统一**

### 重构前后对比

#### 3.1 目录结构对齐

**重构前：**
```
src/
├── components/
│   └── ErrorBoundary.tsx
├── pages/
│   ├── Orders.tsx
│   └── Stats.tsx
├── utils/
│   └── helpers.ts
└── App.tsx
```

**重构后（与react-app-2对齐）：**
```
src/
├── components/
│   ├── ErrorFallback.tsx
│   └── Layout/
│       ├── AppHeader.tsx
│       ├── AppSidebar.tsx
│       └── AppFooter.tsx
├── pages/
│   ├── OrderList.tsx
│   ├── OrderDetail.tsx
│   └── OrderStats.tsx
├── context/
│   └── OrderContext.tsx
├── styles/
│   ├── App.css
│   └── index.css
├── App.tsx
├── main.tsx
└── shared-stub.ts
```

#### 3.2 配置文件统一

**package.json 对齐：**
```json
{
  "name": "react-order-management",
  "version": "1.0.0",
  "scripts": {
    "dev": "vite --port 3003 --host 0.0.0.0",
    "build": "tsc && vite build",
    "preview": "vite preview --port 3003",
    "type-check": "tsc --noEmit",
    "lint": "eslint src --ext .ts,.tsx",
    "lint:fix": "eslint src --ext .ts,.tsx --fix"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.8.1",
    "antd": "^5.2.1",
    "react-helmet-async": "^1.3.0",
    "react-error-boundary": "^3.1.4"
  }
}
```

**vite.config.ts 对齐：**
```typescript
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import legacy from 'vite-plugin-legacy-qiankun';

export default defineConfig({
  plugins: [
    react(),
    legacy('react-order-management', {
      devSandbox: true
    })
  ],
  server: {
    port: 3003,
    host: '0.0.0.0',
    cors: true
  },
  build: {
    target: 'esnext',
    minify: false,
    cssCodeSplit: false,
    rollupOptions: {
      output: {
        format: 'umd',
        entryFileNames: 'js/[name].[hash].js',
        chunkFileNames: 'js/[name].[hash].js',
        assetFileNames: (assetInfo) => {
          if (assetInfo.name?.endsWith('.css')) {
            return 'css/[name].[hash].[ext]';
          }
          return 'assets/[name].[hash].[ext]';
        }
      }
    }
  },
  define: {
    'process.env': process.env
  }
});
```

#### 3.3 状态管理对齐

**Context API 实现：**
```typescript
// src/context/OrderContext.tsx
import React, { createContext, useContext, useReducer, ReactNode } from 'react';

// 订单状态类型定义
export type OrderStatus = 'pending' | 'confirmed' | 'processing' | 'shipped' | 'completed' | 'cancelled';
export type PaymentStatus = 'unpaid' | 'paid' | 'refunded';
export type PaymentMethod = 'alipay' | 'wechat' | 'credit_card' | 'bank_transfer';

export interface Address {
  id: string;
  name: string;
  phone: string;
  province: string;
  city: string;
  district: string;
  street: string;
  zipCode: string;
  isDefault: boolean;
}

export interface OrderItem {
  id: string;
  productId: string;
  productName: string;
  productImage?: string;
  quantity: number;
  unitPrice: number;
  totalPrice: number;
  specifications?: Record<string, any>;
}

export interface Order {
  id: string;
  orderNumber: string;
  createdAt: string;
  updatedAt: string;
  customerId: string;
  customerName: string;
  customerEmail: string;
  customerPhone: string;
  items: OrderItem[];
  totalAmount: number;
  status: OrderStatus;
  paymentStatus: PaymentStatus;
  paymentMethod: PaymentMethod;
  shippingAddress: Address;
  billingAddress: Address;
  notes?: string;
}

interface OrderState {
  orders: Order[];
  currentOrder: Order | null;
  loading: boolean;
  error: string | null;
}

// Action 类型定义
type OrderAction =
  | { type: 'SET_ORDERS'; payload: Order[] }
  | { type: 'ADD_ORDER'; payload: Order }
  | { type: 'UPDATE_ORDER'; payload: { id: string; updates: Partial<Order> } }
  | { type: 'DELETE_ORDER'; payload: string }
  | { type: 'SET_CURRENT_ORDER'; payload: Order | null }
  | { type: 'SET_LOADING'; payload: boolean }
  | { type: 'SET_ERROR'; payload: string | null }
  | { type: 'RESET' };

// Reducer 函数
function orderReducer(state: OrderState, action: OrderAction): OrderState {
  switch (action.type) {
    case 'SET_ORDERS':
      return { ...state, orders: action.payload, loading: false, error: null };
    
    case 'ADD_ORDER':
      return { ...state, orders: [...state.orders, action.payload] };
    
    case 'UPDATE_ORDER':
      return {
        ...state,
        orders: state.orders.map(order =>
          order.id === action.payload.id
            ? { ...order, ...action.payload.updates }
            : order
        )
      };
    
    case 'DELETE_ORDER':
      return {
        ...state,
        orders: state.orders.filter(order => order.id !== action.payload)
      };
    
    case 'SET_CURRENT_ORDER':
      return { ...state, currentOrder: action.payload };
    
    case 'SET_LOADING':
      return { ...state, loading: action.payload };
    
    case 'SET_ERROR':
      return { ...state, error: action.payload, loading: false };
    
    case 'RESET':
      return initialState;
    
    default:
      return state;
  }
}

// 初始状态
const initialState: OrderState = {
  orders: [],
  currentOrder: null,
  loading: false,
  error: null
};

// Context 创建
const OrderContext = createContext<{
  state: OrderState;
  actions: {
    setOrders: (orders: Order[]) => void;
    addOrder: (order: Order) => void;
    updateOrder: (id: string, updates: Partial<Order>) => void;
    deleteOrder: (id: string) => void;
    setCurrentOrder: (order: Order | null) => void;
    setLoading: (loading: boolean) => void;
    setError: (error: string | null) => void;
    reset: () => void;
  };
} | null>(null);

// Provider 组件
export const OrderProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [state, dispatch] = useReducer(orderReducer, initialState);

  const actions = {
    setOrders: (orders: Order[]) => dispatch({ type: 'SET_ORDERS', payload: orders }),
    addOrder: (order: Order) => dispatch({ type: 'ADD_ORDER', payload: order }),
    updateOrder: (id: string, updates: Partial<Order>) => 
      dispatch({ type: 'UPDATE_ORDER', payload: { id, updates } }),
    deleteOrder: (id: string) => dispatch({ type: 'DELETE_ORDER', payload: id }),
    setCurrentOrder: (order: Order | null) => 
      dispatch({ type: 'SET_CURRENT_ORDER', payload: order }),
    setLoading: (loading: boolean) => dispatch({ type: 'SET_LOADING', payload: loading }),
    setError: (error: string | null) => dispatch({ type: 'SET_ERROR', payload: error }),
    reset: () => dispatch({ type: 'RESET' })
  };

  return (
    <OrderContext.Provider value={{ state, actions }}>
      {children}
    </OrderContext.Provider>
  );
};

// Hook
export const useOrderContext = () => {
  const context = useContext(OrderContext);
  if (!context) {
    throw new Error('useOrderContext must be used within an OrderProvider');
  }
  return context;
};
```

### 重构过程中遇到的问题

#### 3.4 依赖版本冲突

**问题：**
```bash
npm ERR! peer dep missing: react@^17.0.0, required by some-package@1.0.0
```

**解决方案：**
```json
// 统一依赖版本
{
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "antd": "^5.2.1"
  },
  "resolutions": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  }
}
```

#### 3.5 样式冲突问题

**问题：**
CSS 类名冲突导致样式覆盖

**解决方案：**
```css
/* 使用应用特定的前缀 */
.order-app-layout {
  min-height: 100vh;
  background: #f5f5f5;
}

.order-app-main {
  padding: 24px;
  background: #fff;
  min-height: calc(100vh - 64px);
}

.order-app-container {
  max-width: 1200px;
  margin: 0 auto;
}

/* 订单列表样式 */
.order-list-container {
  background: #fff;
  border-radius: 8px;
  padding: 24px;
}

.order-list-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16px;
}

.order-list-filters {
  display: flex;
  gap: 16px;
  margin-bottom: 16px;
  flex-wrap: wrap;
}
```

---

## 4. 主应用setup.ts语法错误修复

### 问题描述

在主应用的 `setup.ts` 文件中出现语法错误，影响了子应用的正常加载：

```typescript
// 错误信息
SyntaxError: Unexpected token ':'
TypeError: Cannot read properties of undefined (reading 'mount')
```

### 根本原因分析

1. **TypeScript语法错误**
   - 接口定义语法不正确
   - 类型注解使用错误

2. **qiankun配置错误**
   - 子应用注册配置有误
   - 生命周期函数调用失败

### 具体错误代码

**错误的setup.ts：**
```typescript
// ❌ 错误：语法错误
interface MicroAppConfig: {
  name: string,
  entry: string,
  container: string,
  activeRule: string,
}

const apps: MicroAppConfig[] = [
  {
    name: 'react-order-management',
    entry: '//localhost:3003',
    container: '#subapp-viewport',
    activeRule: '/order-management',
  }
];

// ❌ 错误：异步处理不当
registerMicroApps(apps);
start();
```

### 解决方案

**正确的setup.ts：**
```typescript
// ✅ 正确：正确的接口定义
interface MicroAppConfig {
  name: string;
  entry: string;
  container: string;
  activeRule: string;
  props?: Record<string, any>;
}

// ✅ 正确：完整的应用配置
const microApps: MicroAppConfig[] = [
  {
    name: 'react-order-management',
    entry: process.env.NODE_ENV === 'development' 
      ? '//localhost:3003' 
      : '/order-management/',
    container: '#subapp-viewport',
    activeRule: '/order-management',
    props: {
      routerBase: '/order-management',
      appName: 'react-order-management'
    }
  },
  // 其他子应用配置...
];

// ✅ 正确：错误处理和日志
registerMicroApps(microApps, {
  beforeLoad: (app) => {
    console.log('Loading micro app:', app.name);
    return Promise.resolve();
  },
  beforeMount: (app) => {
    console.log('Mounting micro app:', app.name);
    return Promise.resolve();
  },
  afterMount: (app) => {
    console.log('Mounted micro app:', app.name);
    return Promise.resolve();
  },
  beforeUnmount: (app) => {
    console.log('Unmounting micro app:', app.name);
    return Promise.resolve();
  },
  afterUnmount: (app) => {
    console.log('Unmounted micro app:', app.name);
    return Promise.resolve();
  }
});

// ✅ 正确：启动配置
start({
  sandbox: {
    strictStyleIsolation: false,
    experimentalStyleIsolation: true
  },
  prefetch: 'all',
  fetch: (url, ...args) => {
    console.log('Fetching:', url);
    return window.fetch(url, ...args);
  }
});
```

### 关键修复点

1. **语法修正**
   - 接口定义使用 `{}` 而非 `:`
   - 属性分隔符使用 `;` 而非 `,`

2. **配置完善**
   - 添加环境变量支持
   - 完善生命周期钩子

3. **错误处理**
   - 添加日志记录
   - 增强调试信息

---

## 5. 路由配置问题

### 问题描述

在微前端环境中，路由配置和导航存在问题：

```javascript
// 错误信息
Error: useNavigate() may be used only in the context of a <Router> component
Cannot read properties of undefined (reading 'pathname')
```

### 根本原因分析

1. **Router上下文缺失**
   - 在qiankun环境中Router配置不当
   - 路由基础路径配置错误

2. **路由状态管理问题**
   - 主应用和子应用路由冲突
   - 路由历史管理不当

### 解决方案

**路由配置修正：**
```typescript
// src/main.tsx
function render(props?: any) {
  const { container, routerBase } = props || {};
  
  // 确定路由基础路径
  const basename = routerBase || (window.__POWERED_BY_QIANKUN__ ? '/order-management' : '/');
  
  // 在qiankun环境中，直接使用传入的容器
  let domElement: HTMLElement | null;
  if (window.__POWERED_BY_QIANKUN__) {
    domElement = container;
  } else {
    domElement = document.getElementById('root');
  }
  
  if (!domElement) {
    globalLogger.error('Root element not found');
    return;
  }

  // 创建或重用 React root
  if (!reactRoot) {
    reactRoot = ReactDOM.createRoot(domElement);
  }

  reactRoot.render(
    <React.StrictMode>
      <ErrorBoundary FallbackComponent={ErrorFallback}>
        <OrderProvider>
          <HelmetProvider>
            <ConfigProvider locale={zhCN}>
              <BrowserRouter basename={basename}>
                <App />
              </BrowserRouter>
            </ConfigProvider>
          </HelmetProvider>
        </OrderProvider>
      </ErrorBoundary>
    </React.StrictMode>
  );

  return reactRoot;
}
```

**路由组件修正：**
```typescript
// src/App.tsx
const App: React.FC = () => {
  return (
    <Layout className="order-app-layout">
      <Content className="order-app-main">
        <div className="order-app-container">
          <Routes>
            <Route path="/" element={<Navigate to="/orders" replace />} />
            <Route path="/orders" element={<OrderList />} />
            <Route path="/orders/:id" element={<OrderDetail />} />
            <Route path="/stats" element={<OrderStats />} />
            <Route path="*" element={<Navigate to="/orders" replace />} />
          </Routes>
        </div>
      </Content>
    </Layout>
  );
};
```

---

## 6. TypeScript类型错误

### 问题描述

开发过程中遇到多个TypeScript类型相关错误：

```typescript
// 错误信息
Property 'container' does not exist on type 'unknown'
Type 'string | undefined' is not assignable to type 'string'
Cannot find module '@shared/types' or its corresponding type declarations
```

### 解决方案

**类型定义完善：**
```typescript
// src/types/index.ts
export interface QiankunProps {
  container?: HTMLElement;
  routerBase?: string;
  [key: string]: any;
}

export interface MicroAppLifeCycle {
  bootstrap: () => Promise<void>;
  mount: (props: QiankunProps) => Promise<void>;
  unmount: () => Promise<void>;
}

// 全局类型声明
declare global {
  interface Window {
    __POWERED_BY_QIANKUN__?: boolean;
    __INJECTED_PUBLIC_PATH_BY_QIANKUN__?: string;
    __MICRO_APP_NAVIGATION__?: any;
  }
}
```

**类型安全的实现：**
```typescript
// src/main.tsx
function render(props?: QiankunProps) {
  const { container, routerBase } = props || {};
  
  // 类型安全的容器获取
  let domElement: HTMLElement | null = null;
  
  if (window.__POWERED_BY_QIANKUN__ && container) {
    domElement = container;
  } else {
    domElement = document.getElementById('root');
  }
  
  if (!domElement) {
    const error = new Error('Root element not found');
    globalLogger.error('Render failed', error, { 
      container: !!container, 
      hasQiankun: !!window.__POWERED_BY_QIANKUN__ 
    });
    return;
  }

  // 类型安全的basename处理
  const basename: string = routerBase || 
    (window.__POWERED_BY_QIANKUN__ ? '/order-management' : '/');

  // ... 渲染逻辑
}
```

---

## 7. 预防措施和最佳实践

### 7.1 开发规范

#### 代码结构规范
```
src/
├── components/          # 公共组件
│   ├── ErrorFallback.tsx
│   └── Layout/         # 布局组件
├── pages/              # 页面组件
├── context/            # Context状态管理
├── hooks/              # 自定义Hooks
├── utils/              # 工具函数
├── types/              # 类型定义
├── styles/             # 样式文件
├── App.tsx             # 主应用组件
├── main.tsx            # 应用入口
└── shared-stub.ts      # 共享库存根
```

#### 命名规范
```typescript
// 组件命名：PascalCase
export const OrderList: React.FC = () => {};

// 文件命名：PascalCase for components, camelCase for utilities
OrderList.tsx
userUtils.ts

// 常量命名：UPPER_SNAKE_CASE
export const EVENT_TYPES = {
  APP_READY: 'APP_READY'
} as const;

// 接口命名：PascalCase with 'I' prefix (optional)
interface Order {
  id: string;
  // ...
}
```

### 7.2 错误处理策略

#### 全局错误边界
```typescript
// src/components/ErrorFallback.tsx
import React from 'react';
import { Result, Button } from 'antd';
import { FallbackProps } from 'react-error-boundary';

const ErrorFallback: React.FC<FallbackProps> = ({ 
  error, 
  resetErrorBoundary 
}) => {
  // 错误上报
  React.useEffect(() => {
    if (error) {
      console.error('Application Error:', {
        message: error.message,
        stack: error.stack,
        timestamp: new Date().toISOString()
      });
    }
  }, [error]);

  return (
    <Result
      status="500"
      title="应用发生错误"
      subTitle={error?.message || '抱歉，应用遇到了意外错误'}
      extra={
        <Button type="primary" onClick={resetErrorBoundary}>
          重新加载
        </Button>
      }
    />
  );
};
```

#### API错误处理
```typescript
// src/utils/apiUtils.ts
export const handleApiError = (error: any): string => {
  if (error.response) {
    // HTTP错误
    return error.response.data?.message || `请求失败 (${error.response.status})`;
  } else if (error.request) {
    // 网络错误
    return '网络连接失败，请检查网络设置';
  } else {
    // 其他错误
    return error.message || '未知错误';
  }
};

export const safeApiCall = async <T>(
  apiCall: () => Promise<T>,
  fallbackValue: T
): Promise<T> => {
  try {
    return await apiCall();
  } catch (error) {
    console.error('API call failed:', error);
    return fallbackValue;
  }
};
```

### 7.3 测试策略

#### 单元测试示例
```typescript
// src/__tests__/OrderList.test.tsx
import { render, screen } from '@testing-library/react';
import { BrowserRouter } from 'react-router-dom';
import { OrderProvider } from '../context/OrderContext';
import OrderList from '../pages/OrderList';

const renderWithProviders = (component: React.ReactElement) => {
  return render(
    <BrowserRouter>
      <OrderProvider>
        {component}
      </OrderProvider>
    </BrowserRouter>
  );
};

describe('OrderList', () => {
  it('should render order list correctly', () => {
    renderWithProviders(<OrderList />);
    expect(screen.getByText('订单列表')).toBeInTheDocument();
  });

  it('should handle empty state', () => {
    renderWithProviders(<OrderList />);
    // 测试空状态显示
  });
});
```

#### 集成测试示例
```typescript
// src/__tests__/integration/qiankun.test.ts
import { createLifecyle, getMicroApp } from 'vite-plugin-legacy-qiankun';

describe('Qiankun Integration', () => {
  it('should export lifecycle functions correctly', () => {
    const microApp = getMicroApp('react-order-management');
    expect(microApp).toBeDefined();
    expect(typeof microApp.bootstrap).toBe('function');
    expect(typeof microApp.mount).toBe('function');
    expect(typeof microApp.unmount).toBe('function');
  });

  it('should handle mount with valid props', async () => {
    const mockContainer = document.createElement('div');
    const props = {
      container: mockContainer,
      routerBase: '/order-management'
    };

    // 测试挂载过程
    const microApp = getMicroApp('react-order-management');
    await expect(microApp.mount(props)).resolves.not.toThrow();
  });
});
```

### 7.4 性能优化

#### 代码分割
```typescript
// src/pages/index.tsx
import { lazy } from 'react';

// 懒加载页面组件
export const OrderList = lazy(() => import('./OrderList'));
export const OrderDetail = lazy(() => import('./OrderDetail'));
export const OrderStats = lazy(() => import('./OrderStats'));
```

#### 内存管理
```typescript
// src/hooks/useCleanup.ts
import { useEffect, useRef } from 'react';

export const useCleanup = (cleanup: () => void) => {
  const cleanupRef = useRef(cleanup);
  cleanupRef.current = cleanup;

  useEffect(() => {
    return () => {
      cleanupRef.current();
    };
  }, []);
};

// 使用示例
const OrderList: React.FC = () => {
  useCleanup(() => {
    // 清理事件监听器、定时器等
    globalEventBus.off('orderUpdate', handleOrderUpdate);
  });

  // 组件逻辑...
};
```

### 7.5 调试工具配置

#### 开发环境配置
```typescript
// src/utils/devTools.ts
export const enableDevTools = () => {
  if (process.env.NODE_ENV === 'development') {
    // React DevTools
    if (typeof window !== 'undefined') {
      window.__REACT_DEVTOOLS_GLOBAL_HOOK__ = 
        window.__REACT_DEVTOOLS_GLOBAL_HOOK__ || {};
    }

    // 全局调试函数
    (window as any).__DEBUG__ = {
      globalEventBus,
      globalLogger,
      // 其他调试工具
    };
  }
};
```

#### 日志配置
```typescript
// src/utils/logger.ts
class Logger {
  private isDev = process.env.NODE_ENV === 'development';

  info(message: string, data?: any) {
    if (this.isDev) {
      console.log(`[${new Date().toISOString()}] INFO: ${message}`, data);
    }
  }

  error(message: string, error?: Error, data?: any) {
    console.error(`[${new Date().toISOString()}] ERROR: ${message}`, error, data);
    
    // 生产环境错误上报
    if (!this.isDev && error) {
      this.reportError(error, { message, data });
    }
  }

  private reportError(error: Error, context: any) {
    // 错误上报逻辑
    fetch('/api/errors', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        message: error.message,
        stack: error.stack,
        context,
        timestamp: new Date().toISOString(),
        userAgent: navigator.userAgent
      })
    }).catch(console.error);
  }
}

export const logger = new Logger();
```

## 总结

通过系统性地记录和解决这些问题，我们建立了完整的问题预防和解决机制：

1. **问题分类记录**：详细记录每类问题的症状、原因和解决方案
2. **代码示例对比**：提供错误和正确的代码实现对比
3. **最佳实践总结**：建立开发规范和预防措施
4. **测试策略制定**：确保问题不再复现
5. **工具配置优化**：提升开发和调试效率

这套完整的问题记录和解决方案将帮助团队在后续开发中避免类似问题，提高代码质量和开发效率。

## 相关文档

- [项目开发指南](../../../docs/DEVELOPMENT_GUIDE.md)
- [Qiankun故障排除指南](../../../docs/qiankun-troubleshooting-guide.md)
- [共享库导出问题解决方案](../../../shared/EXPORT_ISSUES_RESOLUTION.md)
- [故障排除总结](../../../shared/TROUBLESHOOTING_SUMMARY.md)